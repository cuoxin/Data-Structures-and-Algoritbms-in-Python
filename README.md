# 前言<br id="0">
无，认真学习

# 目录<br id="3">

- [前言](#0)
- [目录](#3)
- [第一章](#7)
    - [算法的代价及其度量](#8)
        - [大 O 记法](#9)
            - [定义](#10)
        - [常用的渐近复杂度函数](#14)
        - [计算规则](#25)

# 第一章<br id="7">
## 算法的代价及其度量<br id="8">
### 大 O 记法<br id="9">
#### 定义<br id="10">

对于单调的函数 f ，如果存在一个整数函数 g 和实常数 c(c>0)，使得对于充分大的 n 总有 f(n) <= c * g(n)，就说 g 是 f 的一个渐进函数(忽略常量因子)，记为 f(n) = O(g(n))。显然，f(n) = O(g(n)) 说明在趋于无穷的极限意义下，函数 f 的增长速度受到函数 g 的制约。

### 常用的渐近复杂度函数<br id="14">

- O(1)  常量复杂度
- O(log n)  对数复杂度
- O(n)  线性复杂度
- O(n^2^) 平方复杂度
- O(n^3^) 立方复杂度
- O(2^n^) 指数复杂度

![复杂度图像](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2111815583,2613041922&fm=26&gp=0.jpg)

### 计算规则<br id="25">

0. 基本操作，即正常顺序执行，O(1)。有函数时应该带入函数的复杂度计算。
1. 加法规则，即算法A(复杂度 T~1~(n))和算法B(复杂度 T~2~(n)) 按顺序执行，此时 T~总~ = MAX(T~1~(n), T~2~(n))。
2. 乘法规则，即算法A(复杂度 T~1~(n))和算法B(复杂度 T~2~(n)) 按嵌套执行，此时 T~总~ = T~1~(n) * T~2~(n)。
3. 分支，例如两个分支下分别为算法A和算法B，此时整个判断算法的复杂度为 T~总~ = MAX(T~1~(n), T~2~(n))。

P~34~